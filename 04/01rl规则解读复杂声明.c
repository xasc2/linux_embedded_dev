
1、复杂类型声明：
//左右法则:首先从最里面的圆括号(所谓最里面就是一个未声明的标示符)看起,然后往右看,再往左看.每当遇到圆括号( 这个是指")",  遇到"("不跳转 )时候,就应该跳转阅读方向.一旦解析完圆括号里面的所有的内容,就跳出这个圆括号.重复这个过程,知道整个声明解析完毕.
/*
*  指针
[] 数组
() 函数,增加优先级

* < [] ()


*/
int *ps[5];
int (*ps)[5];
int *ps();
int (*ps)();


int (*func)(int * a, void (*handle)(int b));
//func是一个指针,指向一个函数,该函数包含一个参数,参数类型是int *,返回值为int



int (*func[2])(int *);
//func是一个有两个元素的数组,每个成员都是一个指针,该指针指向一个函数,该函数的有一个类型为int *的参数,返回值为int 

int (*(*func)[2])(int *);
//func是一个指针,指向有两个元素的数组,每个数组是一个指针,指向一个函数,该函数的参数是int *, 返回值是int

int (*(*func)(int *))[2];
//func是一个指针,指向一个函数,函数的参数是int *,返回值是一个指针,该指针指向一个有两个元素的数组,每个数组成员是int类型


int *(*(*func)(int *))[2];
//func是一个指针,指向一个函数,函数的参数是int *,返回值是一个指针,该指针指向一个有两个元素的数组,每个数组成员是int *类型的指针

void (*signal(int signum, void (*handler)(int)))(int);
//signal是一个函数,有两个参数,一个参数一个int 类型,第二个参数是函数指针,返回值是一个函数指针


int (*func)(int *, int (*)(int *));
//func是一个指针,指向一个函数,有两个参数,返回值为int.一个参数是int *,第二个参数是指针,指向函数,该函数参数int *,返回值为int.

int *(*(*func)[2])(int* (*)[2], void (*)(int (*)[2]));
//func是一个指针,指向一个有两个元素的数组,每个元素都是一个指针,指向一个函数,该函数有两个参数,返回值int *.第一个参数是一个指针,指向有两个元素的数组,每个成员成员是int *指针,第二个参数是一个指针,指向一个函数,函数的参数是一个指向有两个元素数组,每个数组元素类型是int,返回值void



int func[2](void);  //
int func(void)[2];  //

int *(*func(int (*)[2], int (*(*)(int (*)(int, int),
 int (*)[2]))[2]))[2];


//func是一个函数,第一个参数是一个指针,指向有两个int类型的数组,第二参数是一个指针,指向一个函数,这个函数第一个参数,是一个指针,指向一个函数,这个函数有两个int类型参数,返回值是int型,第二个参数是...,返回值....,返回值是一个指针,指针指向一个有两个元素的数组,每个元素都是int *指针.


2、请为下列变量和函数编写声明：
1.p是指向函数的指针，并且此函数以字符型指针作为实际参数，函数返回的也是字符型指针。
(char * (*p)(char *))p2;
void *p2;


2. a是含有4个元素的数组，且每个元素都是指向函数的指针，而这些函数都是没有实际参数且无返回值的。a的元素初始指向的函数名分别是foo1, foo2, foo3, foo4.
void (*a[4])(void) = {foo1, foo2, foo3, foo4};


3. f是带有两个实际参数的函数：一个参数是指向结构的指针p, 且此结构标签为t; 另一个参数是长整数n. f返回指向函数的指针，且指向的函数没有实际参数也无返回值。
void  (*f(struct t * p, long n))(void)


4. b是含有10个元素的数组，且每个元素都是指向函数的指针，而这些函数都有两个int型实际参数且返回标签为t的结构。
struct t (*b[10])(int , int);

